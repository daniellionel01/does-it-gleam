[
  {
    "id": "fizzbuzz",
    "title": "FizzBuzz",
    "prompt": "Write a function that returns the appropriate string for a given number:\n- \"FizzBuzz\" if divisible by 15\n- \"Fizz\" if divisible by 3 (but not 15)\n- \"Buzz\" if divisible by 5 (but not 15)\n- The number as a string otherwise\n\nFunction signature:\n```gleam\npub fn fizzbuzz(n: Int) -> String\n```",
    "testSetup": [],
    "extraTestImports": [],
    "assertions": [
      { "actual": "solution.fizzbuzz(3)", "expected": "\"Fizz\"" },
      { "actual": "solution.fizzbuzz(5)", "expected": "\"Buzz\"" },
      { "actual": "solution.fizzbuzz(15)", "expected": "\"FizzBuzz\"" },
      { "actual": "solution.fizzbuzz(7)", "expected": "\"7\"" },
      { "actual": "solution.fizzbuzz(30)", "expected": "\"FizzBuzz\"" },
      { "actual": "solution.fizzbuzz(1)", "expected": "\"1\"" }
    ]
  },
  {
    "id": "fibonacci",
    "title": "Fibonacci",
    "prompt": "Write a function that returns the nth Fibonacci number (0-indexed).\n- fib(0) = 0\n- fib(1) = 1\n- fib(n) = fib(n-1) + fib(n-2)\n\nFunction signature:\n```gleam\npub fn fib(n: Int) -> Int\n```",
    "testSetup": [],
    "extraTestImports": [],
    "assertions": [
      { "actual": "solution.fib(0)", "expected": "0" },
      { "actual": "solution.fib(1)", "expected": "1" },
      { "actual": "solution.fib(2)", "expected": "1" },
      { "actual": "solution.fib(10)", "expected": "55" },
      { "actual": "solution.fib(15)", "expected": "610" },
      { "actual": "solution.fib(20)", "expected": "6765" }
    ]
  },
  {
    "id": "factorial",
    "title": "Factorial",
    "prompt": "Write a factorial function that calculates n! (n factorial).\n- factorial(0) = 1\n- factorial(n) = n * factorial(n-1)\n\nFunction signature:\n```gleam\npub fn factorial(n: Int) -> Int\n```",
    "testSetup": [],
    "extraTestImports": [],
    "assertions": [
      { "actual": "solution.factorial(0)", "expected": "1" },
      { "actual": "solution.factorial(1)", "expected": "1" },
      { "actual": "solution.factorial(5)", "expected": "120" },
      { "actual": "solution.factorial(10)", "expected": "3_628_800" },
      { "actual": "solution.factorial(7)", "expected": "5040" }
    ]
  },
  {
    "id": "reverse_string",
    "title": "String Reverse",
    "prompt": "Write a function that reverses a string. Use the `gleam/string` module.\n\nFunction signature:\n```gleam\npub fn reverse_string(s: String) -> String\n```",
    "testSetup": [],
    "extraTestImports": [],
    "assertions": [
      { "actual": "solution.reverse_string(\"hello\")", "expected": "\"olleh\"" },
      { "actual": "solution.reverse_string(\"\")", "expected": "\"\"" },
      { "actual": "solution.reverse_string(\"Gleam\")", "expected": "\"maelG\"" },
      { "actual": "solution.reverse_string(\"a\")", "expected": "\"a\"" },
      { "actual": "solution.reverse_string(\"racecar\")", "expected": "\"racecar\"" }
    ]
  },
  {
    "id": "tuple_swap",
    "title": "Tuple Swap",
    "prompt": "Write a function that swaps the elements of a 2-tuple.\n\nFunction signature:\n```gleam\npub fn swap(tuple: #(a, b)) -> #(b, a)\n```",
    "testSetup": [],
    "extraTestImports": [],
    "assertions": [
      { "actual": "solution.swap(#(1, \"hello\"))", "expected": "#(\"hello\", 1)" },
      { "actual": "solution.swap(#(True, False))", "expected": "#(False, True)" },
      { "actual": "solution.swap(#(1.5, 2))", "expected": "#(2, 1.5)" },
      { "actual": "solution.swap(#(\"a\", \"b\"))", "expected": "#(\"b\", \"a\")" }
    ]
  },
  {
    "id": "greetings",
    "title": "Greetings (Records)",
    "prompt": "Define a `Person` record with `name` (String) and `age` (Int).\nWrite a `greet` function that returns a greeting for a person:\n- If age < 18: \"Hello, young {name}!\"\n- If age >= 18: \"Hello, {name}!\"\n\nFunction signature:\n```gleam\npub type Person {\n  Person(name: String, age: Int)\n}\n\npub fn greet(person: Person) -> String\n```",
    "testSetup": [],
    "extraTestImports": [],
    "assertions": [
      { "actual": "solution.greet(solution.Person(\"Alice\", 25))", "expected": "\"Hello, Alice!\"" },
      { "actual": "solution.greet(solution.Person(\"Bob\", 12))", "expected": "\"Hello, young Bob!\"" },
      { "actual": "solution.greet(solution.Person(\"Charlie\", 18))", "expected": "\"Hello, Charlie!\"" },
      { "actual": "solution.greet(solution.Person(\"Diana\", 17))", "expected": "\"Hello, young Diana!\"" },
      { "actual": "solution.greet(solution.Person(\"Eve\", 0))", "expected": "\"Hello, young Eve!\"" }
    ]
  },
  {
    "id": "second",
    "title": "Second List Item",
    "prompt": "Write a function that returns the second element of a list. Return `Ok(value)` if it exists, `Error(Nil)` otherwise.\n\nFunction signature:\n```gleam\npub fn second(list: List(a)) -> Result(a, Nil)\n```",
    "testSetup": [],
    "extraTestImports": [],
    "assertions": [
      { "actual": "solution.second([1, 2, 3])", "expected": "Ok(2)" },
      { "actual": "solution.second([\"a\", \"b\"])", "expected": "Ok(\"b\")" },
      { "actual": "solution.second([1])", "expected": "Error(Nil)" },
      { "actual": "solution.second([])", "expected": "Error(Nil)" },
      { "actual": "solution.second([1, 2])", "expected": "Ok(2)" },
      { "actual": "solution.second([True, False, True])", "expected": "Ok(False)" }
    ]
  },
  {
    "id": "sum",
    "title": "List Sum",
    "prompt": "Write a function that sums all integers in a list. Return 0 for an empty list.\n\nFunction signature:\n```gleam\npub fn sum(list: List(Int)) -> Int\n```",
    "testSetup": [],
    "extraTestImports": [],
    "assertions": [
      { "actual": "solution.sum([1, 2, 3, 4, 5])", "expected": "15" },
      { "actual": "solution.sum([])", "expected": "0" },
      { "actual": "solution.sum([10, -5, 3])", "expected": "8" },
      { "actual": "solution.sum([0, 0, 0])", "expected": "0" },
      { "actual": "solution.sum([-1, -2, -3])", "expected": "-6" }
    ]
  },
  {
    "id": "product",
    "title": "List Product",
    "prompt": "Write a function that multiplies all integers in a list. Return 1 for an empty list.\n\nFunction signature:\n```gleam\npub fn product(list: List(Int)) -> Int\n```",
    "testSetup": [],
    "extraTestImports": [],
    "assertions": [
      { "actual": "solution.product([1, 2, 3, 4])", "expected": "24" },
      { "actual": "solution.product([])", "expected": "1" },
      { "actual": "solution.product([2, 3, 5])", "expected": "30" },
      { "actual": "solution.product([5])", "expected": "5" },
      { "actual": "solution.product([2, 0, 3])", "expected": "0" },
      { "actual": "solution.product([-1, 2, 3])", "expected": "-6" }
    ]
  },
  {
    "id": "shape_area",
    "title": "Shape Area",
    "prompt": "Define a `Shape` type with variants Circle(radius: Float), Rectangle(width: Float, height: Float), Square(side: Float).\nWrite an `area` function that calculates the area of any shape. Use `3.14159` as the value for pi.\n\nFunction signature:\n```gleam\npub type Shape {\n  Circle(Float)\n  Rectangle(Float, Float)\n  Square(Float)\n}\n\npub fn area(shape: Shape) -> Float\n```",
    "testSetup": [],
    "extraTestImports": [],
    "assertions": [
      { "actual": "solution.area(solution.Circle(1.0))", "expected": "3.14159" },
      { "actual": "solution.area(solution.Circle(2.0))", "expected": "12.56636" },
      { "actual": "solution.area(solution.Rectangle(3.0, 4.0))", "expected": "12.0" },
      { "actual": "solution.area(solution.Rectangle(1.5, 2.0))", "expected": "3.0" },
      { "actual": "solution.area(solution.Square(5.0))", "expected": "25.0" },
      { "actual": "solution.area(solution.Square(0.5))", "expected": "0.25" }
    ]
  },
  {
    "id": "matrix_multiply",
    "title": "Matrix Multiplication",
    "prompt": "Represent matrices as `List(List(Int))` where each inner list is a row.\nWrite a function that multiplies two matrices if dimensions are compatible.\nReturn `Error(Nil)` if multiplication is not possible (columns of A != rows of B).\n\nFunction signature:\n```gleam\npub fn matrix_multiply(\n  a: List(List(Int)),\n  b: List(List(Int))\n) -> Result(List(List(Int)), Nil)\n```",
    "testSetup": [],
    "extraTestImports": [],
    "assertions": [
      {
        "actual": "solution.matrix_multiply([[1, 2, 3], [4, 5, 6]], [[7, 8], [9, 10], [11, 12]])",
        "expected": "Ok([[58, 64], [139, 154]])"
      },
      { "actual": "solution.matrix_multiply([[1, 2]], [[1, 2]])", "expected": "Error(Nil)" },
      { "actual": "solution.matrix_multiply([[1, 2], [3, 4]], [[5, 6], [7, 8]])", "expected": "Ok([[19, 22], [43, 50]])" },
      { "actual": "solution.matrix_multiply([[1]], [[2]])", "expected": "Ok([[2]])" },
      { "actual": "solution.matrix_multiply([], [[1]])", "expected": "Error(Nil)" },
      { "actual": "solution.matrix_multiply([[1, 2, 3]], [[1], [2], [3]])", "expected": "Ok([[14]])" }
    ]
  },
  {
    "id": "quicksort",
    "title": "Quicksort",
    "prompt": "Implement quicksort for a list of integers. Choose the first element as the pivot.\n\nFunction signature:\n```gleam\npub fn quicksort(list: List(Int)) -> List(Int)\n```",
    "testSetup": [],
    "extraTestImports": [],
    "assertions": [
      { "actual": "solution.quicksort([3, 1, 4, 1, 5, 9, 2, 6])", "expected": "[1, 1, 2, 3, 4, 5, 6, 9]" },
      { "actual": "solution.quicksort([])", "expected": "[]" },
      { "actual": "solution.quicksort([1])", "expected": "[1]" },
      { "actual": "solution.quicksort([5, 4, 3, 2, 1])", "expected": "[1, 2, 3, 4, 5]" },
      { "actual": "solution.quicksort([1, 1, 1, 1])", "expected": "[1, 1, 1, 1]" },
      { "actual": "solution.quicksort([1, 2, 3, 4, 5])", "expected": "[1, 2, 3, 4, 5]" }
    ]
  },
  {
    "id": "is_prime",
    "title": "Prime Check",
    "prompt": "Write a function that determines if a positive integer is prime. A prime number is greater than 1 and only divisible by 1 and itself. Return `False` for numbers less than 2.\n\nFunction signature:\n```gleam\npub fn is_prime(n: Int) -> Bool\n```",
    "testSetup": [],
    "extraTestImports": [],
    "assertions": [
      { "actual": "solution.is_prime(2)", "expected": "True" },
      { "actual": "solution.is_prime(3)", "expected": "True" },
      { "actual": "solution.is_prime(17)", "expected": "True" },
      { "actual": "solution.is_prime(97)", "expected": "True" },
      { "actual": "solution.is_prime(1)", "expected": "False" },
      { "actual": "solution.is_prime(0)", "expected": "False" },
      { "actual": "solution.is_prime(4)", "expected": "False" },
      { "actual": "solution.is_prime(15)", "expected": "False" },
      { "actual": "solution.is_prime(100)", "expected": "False" },
      { "actual": "solution.is_prime(7919)", "expected": "True" }
    ]
  },
  {
    "id": "json_encoder",
    "title": "JSON Encoder",
    "prompt": "Given the `User` type below, write a JSON encoder using `gleam/json`. The output should be a JSON object with \"name\" and \"age\" fields.\n\nFunction signature:\n```gleam\nimport gleam/json\n\npub type User {\n  User(name: String, age: Int)\n}\n\npub fn encode_user(user: User) -> String\n```",
    "testSetup": [],
    "extraTestImports": [],
    "assertions": [
      {
        "actual": "solution.encode_user(solution.User(\"Alice\", 30))",
        "expected": "\"{\\\"name\\\":\\\"Alice\\\",\\\"age\\\":30}\""
      },
      {
        "actual": "solution.encode_user(solution.User(\"Bob\", 25))",
        "expected": "\"{\\\"name\\\":\\\"Bob\\\",\\\"age\\\":25}\""
      },
      {
        "actual": "solution.encode_user(solution.User(\"Charlie\", 0))",
        "expected": "\"{\\\"name\\\":\\\"Charlie\\\",\\\"age\\\":0}\""
      }
    ]
  },
  {
    "id": "json_decoder",
    "title": "JSON Decoder",
    "prompt": "Write a JSON decoder for the `User` type using `gleam/dynamic/decode`. The decoder should parse a JSON object with \"name\" (string) and \"age\" (int) fields.\n\nFunction signature:\n```gleam\nimport gleam/dynamic/decode\n\npub type User {\n  User(name: String, age: Int)\n}\n\npub fn user_decoder() -> decode.Decoder(User)\n```\n\nNote: Tests will use `gleam/json.parse(json_string, your_decoder)`.",
    "testSetup": [],
    "extraTestImports": ["gleam/json", "gleam/result"],
    "assertions": [
      {
        "actual": "json.parse(\"{\\\"name\\\":\\\"Alice\\\",\\\"age\\\":30}\", solution.user_decoder())",
        "expected": "Ok(solution.User(\"Alice\", 30))"
      },
      {
        "actual": "json.parse(\"{\\\"name\\\":\\\"Bob\\\",\\\"age\\\":25}\", solution.user_decoder())",
        "expected": "Ok(solution.User(\"Bob\", 25))"
      },
      {
        "actual": "result.is_error(json.parse(\"{\\\"name\\\":\\\"Alice\\\"}\", solution.user_decoder()))",
        "expected": "True"
      }
    ]
  },
  {
    "id": "decode_nested_json",
    "title": "Decode Nested JSON",
    "prompt": "Write a decoder for a nested JSON structure. Parse JSON like: `{\"user\": {\"name\": \"...\", \"age\": ...}, \"active\": true}` into the `Account` type below.\n\nFunction signature:\n```gleam\nimport gleam/dynamic/decode\n\npub type User {\n  User(name: String, age: Int)\n}\n\npub type Account {\n  Account(user: User, active: Bool)\n}\n\npub fn account_decoder() -> decode.Decoder(Account)\n```\n\nNote: Tests will use `gleam/json.parse(json_string, your_decoder)`.",
    "testSetup": [],
    "extraTestImports": ["gleam/json"],
    "assertions": [
      {
        "actual": "json.parse(\"{\\\"user\\\":{\\\"name\\\":\\\"Alice\\\",\\\"age\\\":30},\\\"active\\\":true}\", solution.account_decoder())",
        "expected": "Ok(solution.Account(solution.User(\"Alice\", 30), True))"
      },
      {
        "actual": "json.parse(\"{\\\"user\\\":{\\\"name\\\":\\\"Bob\\\",\\\"age\\\":25},\\\"active\\\":false}\", solution.account_decoder())",
        "expected": "Ok(solution.Account(solution.User(\"Bob\", 25), False))"
      }
    ]
  },
  {
    "id": "aoc_day1_calibration",
    "title": "AoC Day 1 Style: Calibration Values",
    "prompt": "Extract calibration values from strings containing digits. For each string, find the first and last digit, then combine them into a two-digit number. If there's only one digit, use it for both first and last. If there are no digits, return 0.\n\nWrite two functions:\n- `extract_calibration_value` for a single string\n- `sum_calibration_values` to sum all values from a list\n\nFunction signatures:\n```gleam\npub fn extract_calibration_value(s: String) -> Int\n\npub fn sum_calibration_values(lines: List(String)) -> Int\n```",
    "testSetup": [],
    "extraTestImports": [],
    "assertions": [
      { "actual": "solution.extract_calibration_value(\"a1b2c3d4e5\")", "expected": "15" },
      { "actual": "solution.extract_calibration_value(\"treb7uchet\")", "expected": "77" },
      { "actual": "solution.extract_calibration_value(\"abc\")", "expected": "0" },
      { "actual": "solution.extract_calibration_value(\"1abc2\")", "expected": "12" },
      { "actual": "solution.extract_calibration_value(\"pqr3stu8vwx\")", "expected": "38" },
      { "actual": "solution.extract_calibration_value(\"a1b2c3d4e5f6g7h8i9\")", "expected": "19" },
      { "actual": "solution.sum_calibration_values([\"a1b2c3d4e5\", \"treb7uchet\"])", "expected": "92" },
      {
        "actual": "solution.sum_calibration_values([\"1abc2\", \"pqr3stu8vwx\", \"a1b2c3d4e5f\"])",
        "expected": "12 + 38 + 15"
      }
    ]
  },
  {
    "id": "aoc_day2_rps",
    "title": "AoC Day 2 Style: Rock Paper Scissors",
    "prompt": "Simulate a Rock Paper Scissors tournament.\n- Opponent plays: A = Rock, B = Paper, C = Scissors\n- Player plays: X = Rock, Y = Paper, Z = Scissors\n\nScore calculation:\n- Shape score: Rock = 1, Paper = 2, Scissors = 3\n- Outcome score: Loss = 0, Draw = 3, Win = 6\n- Total = Shape score + Outcome score\n\nWrite two functions:\n- `round_score` to calculate score for a single round\n- `total_score` to sum scores across all rounds\n\nFunction signatures:\n```gleam\npub fn round_score(opponent: String, player: String) -> Int\n\npub fn total_score(rounds: List(#(String, String))) -> Int\n```",
    "testSetup": [],
    "extraTestImports": [],
    "assertions": [
      { "actual": "solution.round_score(\"A\", \"Y\")", "expected": "8" },
      { "actual": "solution.round_score(\"B\", \"X\")", "expected": "1" },
      { "actual": "solution.round_score(\"C\", \"Z\")", "expected": "6" },
      { "actual": "solution.round_score(\"A\", \"X\")", "expected": "4" },
      { "actual": "solution.round_score(\"A\", \"Z\")", "expected": "3" },
      { "actual": "solution.round_score(\"B\", \"Y\")", "expected": "5" },
      { "actual": "solution.round_score(\"B\", \"Z\")", "expected": "9" },
      { "actual": "solution.round_score(\"C\", \"X\")", "expected": "7" },
      { "actual": "solution.round_score(\"C\", \"Y\")", "expected": "2" },
      { "actual": "solution.total_score([#(\"A\", \"Y\"), #(\"B\", \"X\"), #(\"C\", \"Z\")])", "expected": "15" },
      {
        "actual": "solution.total_score([#(\"A\", \"Y\"), #(\"B\", \"X\"), #(\"C\", \"Z\"), #(\"A\", \"X\"), #(\"B\", \"Y\")])",
        "expected": "24"
      }
    ]
  },
  {
    "id": "binary_search",
    "title": "Binary Search",
    "prompt": "Implement binary search on a sorted list of integers. Return `Ok(index)` if the target is found, `Error(Nil)` if not found. The list is 0-indexed and sorted in ascending order.\n\nFunction signature:\n```gleam\npub fn binary_search(list: List(Int), target: Int) -> Result(Int, Nil)\n```",
    "testSetup": [],
    "extraTestImports": [],
    "assertions": [
      { "actual": "solution.binary_search([1, 3, 5, 7, 9], 5)", "expected": "Ok(2)" },
      { "actual": "solution.binary_search([1, 3, 5, 7, 9], 6)", "expected": "Error(Nil)" },
      { "actual": "solution.binary_search([], 1)", "expected": "Error(Nil)" },
      { "actual": "solution.binary_search([1, 2, 3, 4, 5], 1)", "expected": "Ok(0)" },
      {
        "actual": "solution.binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10)",
        "expected": "Ok(9)"
      },
      { "actual": "solution.binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 1)", "expected": "Ok(0)" },
      { "actual": "solution.binary_search([1, 2, 3, 4, 5], 5)", "expected": "Ok(4)" },
      { "actual": "solution.binary_search([1, 2, 3, 4, 5], 0)", "expected": "Error(Nil)" },
      { "actual": "solution.binary_search([2], 2)", "expected": "Ok(0)" },
      { "actual": "solution.binary_search([2], 1)", "expected": "Error(Nil)" }
    ]
  },
  {
    "id": "pipeline_processing",
    "title": "Pipeline Processing",
    "prompt": "Using Gleam's pipeline operator `|>`, process a list of numbers through multiple steps:\n1. Filter out negative numbers (keep >= 0)\n2. Double each number\n3. Keep only even numbers\n4. Sum the result\n\nWrite a single function that chains these operations.\n\nFunction signature:\n```gleam\npub fn process(numbers: List(Int)) -> Int\n```",
    "testSetup": [],
    "extraTestImports": [],
    "assertions": [
      { "actual": "solution.process([1, -2, 3, 4, -5, 6])", "expected": "28" },
      { "actual": "solution.process([-1, -2, -3])", "expected": "0" },
      { "actual": "solution.process([])", "expected": "0" },
      { "actual": "solution.process([0, 1, 2, 3])", "expected": "12" },
      { "actual": "solution.process([1, 3, 5])", "expected": "18" },
      { "actual": "solution.process([-1, 2, -3, 4])", "expected": "12" }
    ]
  },
  {
    "id": "dict_operations",
    "title": "Dict Operations",
    "prompt": "Write a function that counts occurrences of each element in a list. Return a `Dict` mapping each unique element to its count.\n\nFunction signature:\n```gleam\nimport gleam/dict\n\npub fn count_occurrences(list: List(a)) -> dict.Dict(a, Int)\n```",
    "testSetup": [
      "let d1 = solution.count_occurrences([1, 2, 2, 3, 3, 3])",
      "let d2 = solution.count_occurrences([])",
      "let d3 = solution.count_occurrences([\"a\", \"b\", \"a\", \"a\", \"c\"]) ",
      "let d4 = solution.count_occurrences([1, 1, 1, 1])"
    ],
    "extraTestImports": ["gleam/dict"],
    "assertions": [
      { "actual": "dict.get(d1, 1)", "expected": "Ok(1)" },
      { "actual": "dict.get(d1, 2)", "expected": "Ok(2)" },
      { "actual": "dict.get(d1, 3)", "expected": "Ok(3)" },
      { "actual": "dict.size(d2)", "expected": "0" },
      { "actual": "dict.get(d3, \"a\")", "expected": "Ok(3)" },
      { "actual": "dict.get(d3, \"b\")", "expected": "Ok(1)" },
      { "actual": "dict.get(d3, \"c\")", "expected": "Ok(1)" },
      { "actual": "dict.get(d4, 1)", "expected": "Ok(4)" }
    ]
  }
]
